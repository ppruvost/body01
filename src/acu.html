<!DOCTYPE html>
<html lang="fr">
<head>
    <title>Liaison Points d'Énergie</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body { font-family: Monospace; background-color: #BD786C; margin: 0; overflow: hidden; }
        #pointLabel { position: absolute; left: 10px; top: 50%; transform: translateY(-50%) rotate(-90deg); transform-origin: left top; background: transparent; color: #3a2d27; font-family: Arial, sans-serif; white-space: nowrap; z-index: 9999; pointer-events: none; }
        #pointLabel .point-name { font-weight: bold; font-size: 18px; margin-right: 6px; }
        #pointLabel .copyright { font-size: 11px; font-weight: normal; }
    </style>
</head>
<body id="acu">
    <div id="pointLabel"></div>
    <script src="lib/three/build/three.min.js"></script>
    <script src="lib/three/examples/jsm/loaders/OBJLoader.js"></script>
    <script src="lib/three/examples/jsm/controls/OrbitControls.js"></script>
    <script>
        let container, camera, scene, renderer, controls, raycaster = new THREE.Raycaster(), mouse = new THREE.Vector2(), lastClickedPoint = null;
        const meridianLines = {};

        function createSphere(name, color, x, y, z, view = null) {
            const geometry = new THREE.SphereGeometry(0.3, 32, 32);
            const material = new THREE.MeshLambertMaterial({ color });
            const object = new THREE.Mesh(geometry, material);
            object.name = name; object.position.set(x, y, z); if (view !== null) object.view = view;
            scene.add(object); object.renderOrder = -1;
        }

        function drawMeridianLine(prefix, color) {
            const points = scene.children.filter(obj => obj.type === 'Mesh' && obj.name && obj.name.startsWith(prefix)).sort((a, b) => parseInt(a.name.replace(prefix, '')) - parseInt(b.name.replace(prefix, '')));
            if (points.length < 2) return;
            const positions = []; points.forEach(p => positions.push(p.position.x, p.position.y, p.position.z));
            const geometry = new THREE.BufferGeometry(); geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            const material = new THREE.LineBasicMaterial({ color, linewidth: 1, depthTest: false, transparent: true, opacity: 0.9 });
            const line = new THREE.Line(geometry, material); line.name = `${prefix}_line`; scene.add(line); meridianLines[prefix] = line;
        }

        function init() {
            container = document.createElement('div'); document.body.appendChild(container);
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.5, 2000); camera.position.z = 250;
            scene = new THREE.Scene();
            const ambient = new THREE.AmbientLight(0x101030); scene.add(ambient);
            const directionalLight1 = new THREE.DirectionalLight(0xffeedd); directionalLight1.position.set(0, 0, 1); scene.add(directionalLight1);
            const directionalLight2 = new THREE.DirectionalLight(0xffeedd); directionalLight2.position.set(0, 0, -1); scene.add(directionalLight2);

            const vcPositions = [{ name: 'vc1', x: 0.05, y: -12.7, z: -4.2 }, { name: 'vc2', x: 0.05, y: -6, z: 6.4 } /* ... */];
            vcPositions.forEach(pos => createSphere(pos.name, 0x9370DB, pos.x, pos.y, pos.z));

            const manager = new THREE.LoadingManager();
            const texture = new THREE.TextureLoader(manager).load('three/textura/UV_Grid_Sm.jpg');
            const loaderObj = new THREE.OBJLoader(manager);
            loaderObj.load('three/modelo/corpo.obj', object => {
                object.traverse(child => { if (child instanceof THREE.Mesh) { child.material = new THREE.MeshLambertMaterial({ map: texture, transparent: true, opacity: 0.85 }); child.material.needsUpdate = true; } });
                object.scale.set(1.5, 1.5, 1.5); object.position.set(0, -40, 0); object.renderOrder = -1; scene.add(object);
            });

            renderer = new THREE.WebGLRenderer(); renderer.setClearColor(0xBD786C); renderer.setPixelRatio(window.devicePixelRatio); renderer.setSize(window.innerWidth, window.innerHeight); container.appendChild(renderer.domElement);
            controls = new THREE.OrbitControls(camera, renderer.domElement); controls.damping = 0.2; controls.enableRotate = false; controls.enablePan = false; controls.addEventListener('change', render);
            drawMeridianLine('vc', 0x9370DB); drawMeridianLine('p', 0xf5f5f0); drawMeridianLine('gi', 0x00CED1); drawMeridianLine('e', 0xFFD700);
            window.addEventListener('resize', onWindowResize); window.addEventListener('click', onDocumentClick);
        }

        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
        function onDocumentClick(event) { event.preventDefault(); mouse.x = (event.clientX / window.innerWidth) * 2 - 1; mouse.y = -(event.clientY / window.innerHeight) * 2 + 1; raycaster.setFromCamera(mouse, camera); const intersects = raycaster.intersectObjects(scene.children); if (intersects.length > 0) { const clickedObject = intersects[0].object; document.getElementById('pointLabel').innerHTML = `<span class="point-name">${clickedObject.name.toUpperCase()}</span> <span class="copyright">© bien-etre-geobiologie.fr</span>`; if (lastClickedPoint && lastClickedPoint !== clickedObject) lastClickedPoint.material.color.setHex(lastClickedPoint.originalColor); if (!clickedObject.originalColor) clickedObject.originalColor = clickedObject.material.color.getHex(); clickedObject.material.color.setHex(0xFF0000); lastClickedPoint = clickedObject; } }
        function animate() { requestAnimationFrame(animate); render(); }
        function render() { renderer.render(scene, camera); }
        init(); animate();
    </script>
</body>
</html>
