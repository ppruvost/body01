<!DOCTYPE html>
<html lang="fr">
<head>
    <title>Energy Points Connection</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

    <style>
        body {
            font-family: monospace;
            background-color: #BD786C;
            margin: 0;
            overflow: hidden;
        }

        #pointLabel {
            position: absolute;
            left: 10px;
            top: 50%;
            transform: translateY(-50%) rotate(-90deg);
            transform-origin: left top;
            background: transparent;
            color: #3a2d27;
            font-family: Arial, sans-serif;
            white-space: nowrap;
            z-index: 9999;
            pointer-events: none;
        }

        #pointLabel .point-name {
            font-weight: bold;
            font-size: 18px;
            margin-right: 6px;
        }

        #pointLabel .copyright {
            font-size: 11px;
        }
    </style>
</head>

<body>
<div id="pointLabel"></div>

<script src="js/acu_point.js"></script>
<script src="three/build/three.js"></script>
<script src="three/loaders/OBJLoader.js"></script>
<script src="three/controls/OrbitControls.js"></script>

<script>

/* ============================================================
   GLOBAL VARIABLES
============================================================ */

var container, camera, scene, renderer, controls;
var raycaster = new THREE.Raycaster();
var mouse = new THREE.Vector2();
var INTERSECTED = null;
var clickableObjects = [];
var bodyMesh = null;

var focusCamera = false;
var targetPosition = new THREE.Vector3();
var cameraOffsetX = 0;
var cameraOffsetZ = 45;

var lastSelectedPoint = null;
var curvesData = {};

/* ============================================================
   APPEL DES POINTS
============================================================ */

var sphereGeometry = new THREE.SphereGeometry(0.3, 16, 16);

function createPointMesh(point) {

    const color = getMeridianColor(point.meridian);

    const material = new THREE.MeshLambertMaterial({
        color: color
    });

    const mesh = new THREE.Mesh(
        sphereGeometry,
        material
    );

    mesh.name = point.name;
    mesh.position.set(point.x, point.y, point.z);
    mesh.meridian = point.meridian;
    mesh.view = point.view || 0;
    mesh.originalColor = color;

    scene.add(mesh);
    clickableObjects.push(mesh);
}
/* ================================================
COULEURS DES POINTS
================================================*/
    function getMeridianColor(meridian) {

    const colors = {
        "Poumon": 0xf5f5f0,
        "Gros Intestin": 0x00CED1,
        "Estomac": 0xFFD700,
        "Rate": 0xF4D03F,
        "Coeur": 0xFF0000,
        "Intestin Grele": 0xFF4500,
        "Vessie": 0x1E90FF,
        "Rein": 0x00008B,
        "Foie": 0x228B22,
        "Vesicule Biliaire": 0x32CD32,
        "Vaisseau Conception": 0x9370DB,
        "Vaisseau Gouverneur": 0x8B0000
    };

    return colors[meridian] || 0xffffff;
}

/* ============================================================
   INITIALIZATION
============================================================ */

function init() {
    container = document.createElement('div');
    document.body.appendChild(container);

    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.5,
        2000
    );
    camera.position.z = 250;

    controls = new THREE.OrbitControls(camera);
    controls.enableRotate = false;
    controls.enablePan = false;

    /* LIGHTS */
    scene.add(new THREE.AmbientLight(0x101030));

    var dirLight1 = new THREE.DirectionalLight(0xffeedd);
    dirLight1.position.set(0, 0, 1);
    scene.add(dirLight1);

    var dirLight2 = new THREE.DirectionalLight(0xffeedd);
    dirLight2.position.set(0, 0, -1);
    scene.add(dirLight2);

    /* MERIDIANS POINTS (source acu_point.js) */

    ACU_POINTS.forEach(point => {
        createPointMesh(point);
    });

    /* LOAD BODY MODEL */
    var manager = new THREE.LoadingManager();

    var texture = new THREE.Texture();
    var imageLoader = new THREE.ImageLoader(manager);
    imageLoader.load('three/textura/UV_Grid_Sm.jpg', function(image) {
        texture.image = image;
        texture.needsUpdate = true;
    });

    var objLoader = new THREE.OBJLoader(manager);
    objLoader.load('three/modelo/corpo.obj', function(object) {
        object.traverse(function(child) {
            if (child instanceof THREE.Mesh) {
                child.material.map = texture;
                bodyMesh = child;
            }
        });
        object.position.y = -95;
        scene.add(object);
    });

    /* RENDERER */
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setClearColor(0xBD786C);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
    renderer.setSize(window.innerWidth, window.innerHeight);

    container.appendChild(renderer.domElement);

    window.addEventListener('resize', onWindowResize);
    window.addEventListener('click', onMouseClick);
    window.addEventListener('mousemove', onMouseMove);
}

/* ============================================================
   EVENTS
============================================================ */

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

function onMouseMove(event) {
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
}

function onMouseClick(event) {
    raycaster.setFromCamera(mouse, camera);
    var intersects = raycaster.intersectObjects(clickableObjects, false);

    if (intersects.length === 0) return;

    var selected = intersects[0].object;

    // LABEL
    document.getElementById("pointLabel").innerHTML =
        "<span class='point-name'>" + selected.name.toUpperCase() +
        "</span><span class='copyright'> © bien-etre-geobiologie.fr</span>";

    // Gestion couleur
    if (!selected.originalColor) {
        selected.originalColor = selected.material.color.getHex();
    }

    // Rouge sur le point cliqué
    selected.material.color.setHex(0xff0000);

    // Reprendre couleur ancien point
    if (lastSelectedPoint && lastSelectedPoint !== selected) {
        lastSelectedPoint.material.color.setHex(lastSelectedPoint.originalColor);
    }

    lastSelectedPoint = selected;

    // Focus caméra
    focusOnPoint(selected);

    // Ouvrir le sous-menu correspondant
    openSubMenu(selected.name);
}

/* ============================================================
   CAMERA FOCUS
============================================================ */

function focusOnPoint(object) {
    targetPosition.copy(object.position);
    cameraOffsetX = 0;
    cameraOffsetZ = 45;

    if (object.view === 1) cameraOffsetX = 45;
    if (object.view === -1) cameraOffsetX = -45;
    if (object.view === -2) cameraOffsetZ = -45;

    focusCamera = true;
}

/* ============================================================
   OPEN SUBMENU FUNCTION
============================================================ */

function openSubMenu(pointName) {
    // Ferme tous les sous-menus
    const allSubmenus = document.querySelectorAll('.submenu');
    allSubmenus.forEach(menu => menu.style.display = 'none');

    // Supprime classe active sur tous les items
    const allItems = document.querySelectorAll('.load-content');
    allItems.forEach(item => item.classList.remove('active'));

    // Ouvre l’item correspondant
    const targetItem = document.querySelector(`.load-content[data-id="${pointName}"]`);
    if (targetItem) {
        targetItem.classList.add('active');
        const parentMenu = targetItem.closest('.submenu');
        if (parentMenu) parentMenu.style.display = 'block';
    }
}

/* ============================================================
   MERIDIAN CURVES
============================================================ */

function createMeridianCurveFromData(prefix, color, bodyMesh) {
    if (!curvesData[prefix] || !bodyMesh) return;

    var ray = new THREE.Raycaster();
    var offsetDistance = 0.2;
    var finalPoints = [];

    curvesData[prefix].forEach(function(p) {
        var point = new THREE.Vector3(p.x, p.y, p.z);
        var direction = point.clone().normalize().negate();

        ray.set(point, direction);
        var intersects = ray.intersectObject(bodyMesh, true);

        if (intersects.length > 0 && intersects[0].face) {
            var hit = intersects[0];
            var surfacePoint = hit.point.clone();
            var normal = hit.face.normal.clone();
            normal.applyMatrix3(new THREE.Matrix3().getNormalMatrix(hit.object.matrixWorld)).normalize();
            surfacePoint.add(normal.multiplyScalar(offsetDistance));
            finalPoints.push(surfacePoint);
        } else {
            finalPoints.push(point);
        }
    });

    var geometry = new THREE.Geometry();
    geometry.vertices = finalPoints;

    var material = new THREE.LineBasicMaterial({ color: color });
    var line = new THREE.Line(geometry, material);
    line.raycast = function() {};
    scene.add(line);
}

function getCurveColor(prefix) {

    const map = {
        "p": "Poumon",
        "gi": "Gros Intestin",
        "e": "Estomac",
        "vc": "Vaisseau Conception"
    };

    const meridianName = map[prefix];
    return getMeridianColor(meridianName);
}

/* LOAD MERIDIANS JSON */
fetch("meridians.json")
.then(res => res.json())
.then(data => {
    curvesData = data;
    for (var meridian in curvesData) {
        createMeridianCurveFromData(meridian, getCurveColor(meridian), bodyMesh);
    }
});

/* ============================================================
   ANIMATION LOOP
============================================================ */

function animate() {
    requestAnimationFrame(animate);
    render();
}

function render() {
    if (focusCamera) {
        var target = new THREE.Vector3(
            targetPosition.x + cameraOffsetX,
            targetPosition.y,
            targetPosition.z + cameraOffsetZ
        );

        camera.position.lerp(target, 0.1);
        camera.lookAt(targetPosition);

        if (camera.position.distanceTo(target) < 0.5) {
            focusCamera = false;
            controls.target.copy(targetPosition);
        }
    }

    renderer.render(scene, camera);
}

/* ============================================================
   START
============================================================ */

init();
animate();

</script>
</body>
</html>
