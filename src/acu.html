<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8">
<title>Energy Points Connection</title>

<style>
body {
    margin: 0;
    overflow: hidden;
    background-color: #BD786C;
    font-family: monospace;
}
#pointLabel {
    position: absolute;
    left: 10px;
    top: 50%;
    transform: translateY(-50%) rotate(-90deg);
    color: #3a2d27;
    z-index: 9999;
}
.point-name { font-weight: bold; font-size:18px; }
</style>
</head>

<body>
<div id="pointLabel"></div>

<script src="three/build/three.js"></script>
<script src="three/loaders/OBJLoader.js"></script>
<script src="three/controls/OrbitControls.js"></script>
<script src="js/acu_point.js"></script>
<script src="js/precomputeMeridians.js"></script>

<script>

/* ================= GLOBAL ================= */

var container, camera, scene, renderer, controls;
var raycaster = new THREE.Raycaster();
var mouse = new THREE.Vector2();
var clickableObjects = [];
var bodyMesh = null;
var cameraOffsetX = 0;
var cameraOffsetZ = 45;
var lastSelectedPoint = null;
var curvesData = {};

var sphereGeometry = new THREE.SphereGeometry(0.3,16,16);

/* ================= COLORS ================= */

function getMeridianColor(meridian) {
    const colors = {
        "Maître Coeur": 0x0000FF,
        "Poumon": 0xf5f5f0,
        "Gros Intestin": 0x00CED1,
        "Estomac": 0xFFD700,
        "Rate": 0xF4D03F,
        "Cœur": 0xFF0000,
        "Intestin Grele": 0xFF4500,
        "Vessie": 0x1E90FF,
        "Rein": 0x00008B,
        "Foie": 0x228B22,
        "Vesicule Biliaire": 0x32CD32,
        "Vaisseau Conception": 0x9370DB,
        "Vaisseau Gouverneur": 0x8B0000
    };
    return colors[meridian] || 0xffffff;
}

/* ================= POINTS ================= */

function createPointMesh(point) {
    const material = new THREE.MeshLambertMaterial({
        color: getMeridianColor(point.meridian)
    });

    const mesh = new THREE.Mesh(sphereGeometry, material);
    mesh.name = point.name;
    mesh.position.set(point.x, point.y, point.z);
    mesh.meridian = point.meridian;
    mesh.view = point.view || 0;
    mesh.originalColor = material.color.getHex();

    scene.add(mesh);
    clickableObjects.push(mesh);
}

/* ================= INIT ================= */

function init() {

    container = document.createElement('div');
    document.body.appendChild(container);

    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.5, 2000);
    camera.position.z = 250;

    controls = new THREE.OrbitControls(camera);
    controls.enableRotate = true;
    controls.enableZoom = true;
    controls.enablePan = true;
    controls.enableDamping = true;       // rotation fluide
    controls.dampingFactor = 0.08;

    controls.rotateSpeed = 0.8;
    controls.zoomSpeed = 1.2;
    controls.panSpeed = 0.8;

    controls.minDistance = 40;           // limite zoom proche
    controls.maxDistance = 600;          // limite zoom loin

    controls.target.set(0, 0, 0);        // centre du modèle
    controls.update();

    /* Ombre sur le corps*/
    scene.add(new THREE.AmbientLight(0x101030));

    const d1 = new THREE.DirectionalLight(0xffeedd);
    d1.position.set(0,0,1);
    scene.add(d1);

    const d2 = new THREE.DirectionalLight(0xffeedd);
    d2.position.set(0,0,-1);
    scene.add(d2);

    /* Points */   
    ACU_POINTS.forEach(p => createPointMesh(p));

    /* Meridian Lines */
    buildMeridianLines(scene);

    /* OBJ */
    const loaderObj = new THREE.OBJLoader();
    loaderObj.load('three/modelo/corpo.obj', obj => {
        obj.position.y = -95;
        bodyMesh = obj;
        scene.add(obj);
    });

    renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setClearColor(0xBD786C);
    renderer.setSize(window.innerWidth, window.innerHeight);
    container.appendChild(renderer.domElement);

    window.addEventListener('resize', onWindowResize);
    window.addEventListener('mousemove', onMouseMove);
    window.addEventListener('click', onMouseClick);
}

/* ================= EVENTS ================= */

function onWindowResize() {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

function onMouseMove(event) {
    mouse.x = (event.clientX/window.innerWidth)*2-1;
    mouse.y = -(event.clientY/window.innerHeight)*2+1;
}

function onMouseClick() {
    raycaster.setFromCamera(mouse,camera);
    const intersects = raycaster.intersectObjects(clickableObjects);

    if(!intersects.length) return;

    const selected = intersects[0].object;

    const label = document.getElementById("pointLabel");

    /*================Print Label=============*/
    
    document.getElementById('pointLabel').innerHTML = `<span class="point-name">${clickedObject.name.toUpperCase()}</span> <span class="copyright">© bien-etre-geobiologie.fr</span>`;

    /*===============Focus on Label==========*/
    if(lastSelectedPoint)
        lastSelectedPoint.material.color.setHex(lastSelectedPoint.originalColor);

    selected.material.color.setHex(0xffff00);
    lastSelectedPoint = selected;

    focusOnPoint(selected);
    openSubMenu(selected.name);
}

/* ================= CAMERA ================= */

function focusOnPoint(object){

    const newTarget = object.position.clone();

    controls.target.copy(newTarget);

    camera.position.set(
        newTarget.x + cameraOffsetX,
        newTarget.y + 20,
        newTarget.z + cameraOffsetZ
    );

    controls.update();
}


/* ================= MENU ================= */
function openSubMenu(pointName){

    // envoie l’info à index.html
    window.parent.postMessage({
        type: "selectPoint",
        point: pointName
    }, "*");

}

/* ================= LOOP ================= */

function animate(){
    requestAnimationFrame(animate);
    render();
}

function render(){
        renderer.render(scene,camera);
}

/* ================= START ================= */

init();
animate();

</script>
</body>
</html>
