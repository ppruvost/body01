<!DOCTYPE html>
<html lang="fr">
	<head>
		<title>Points d'Energie</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #BD786C;
				color: #fff;
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>

	<body>
		<script src="three/build/three.js"></script>
		<!-- CHARGE THREE.JS  -->
		<script src="three/loaders/OBJLoader.js"></script>
		<!-- CHARGER L'OBJET -->
		<script src="three/controls/OrbitControls.js"></script>
		<!-- CHARGER LES COMMANDES -> COMMANDES ORBITALES-->
		<script>
			var container;			
			var camera, scene, raycaster, renderer;			
			var mouse = new THREE.Vector2(), INTERSECTED;
			var mouseX = 0, mouseY = 0;
			var windowHalfX = window.innerWidth / 2;			
			var windowHalfY = window.innerHeight / 2;
			var acuX = 0, acuY = 0, acuZ = 0;
			//nitialisation des variables globales utilisées pour l'animation de la caméra
			var focoCamera = false;
			//Variable globale qui contrôlera l'animation de la caméra (activer/désactiver l'animation)
			var uPressed = false;
			var dPressed = false;
			var rPressed = false;
			var lPressed = false;
			var pPressed = false;
			var mPressed = false;
			var idponto = 'e1';
			var p = new THREE.Vector3( 0, 0, 0 );

			init();
			
			animate();			

			function init() {
				
				container = document.createElement( 'div' );
				document.body.appendChild( container );				

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 10, 2000 );				
				
				camera.position.z = 250;
				
				controls = new THREE.OrbitControls( camera );
				
				controls.damping = 0.2;
				controls.addEventListener( 'change', render );

				scene = new THREE.Scene();				

				var ambient = new THREE.AmbientLight( 0x101030 );				
				
				scene.add( ambient );

				var directionalLight = new THREE.DirectionalLight( 0xffeedd );				
				
				directionalLight.position.set( 0, 0, 1 );
				/* En accédant à l'objet position et en invoquant la méthode set, nous définissons la position de la lumière, qui dans ce cas est (0, 0, 1), c'est-à-dire : une lampe parallèle à l'axe Z, émettant de la lumière depuis l'avant. */
				scene.add( directionalLight );

				/* Ajoute la lumière directionnelle à la scène	*/

				var directionalLight = new THREE.DirectionalLight( 0xffeedd );
				directionalLight.position.set( 0, 0, -1 );
				/* La direction de la lumière est (0, 0, -1), c'est-à-dire : une lampe parallèle à l'axe Z, mais inversée, émettant de la lumière par l'arrière */
				scene.add( directionalLight );				

				var geometry = new THREE.SphereGeometry( 0.3, 32, 32 );
				/* Stocke dans la géométrie le résultat du constructeur SphereGeometry, qui reçoit les paramètres suivants :
					radius — rayon de la sphère. Ici, 0,3.
					widthSegments — nombre de segments horizontaux ; influence le contour de la sphère. Ici, 32.
					heightSegments — nombre de segments verticaux ; influence le contour de la sphère. Ici, 32.
					Géométrie utilisée pour toutes les sphères du programme : ACUPONTOS
				*/

				/*Déclarations de tous les domaines ; elles sont analogues, la seule différence résidant dans les noms et les positions : */

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				/* voir https://threejs.org/docs/#Reference/Objects/Mesh */

				object.name = 'cs7';
				/* Crée un attribut de nom qui servira à associer les boutons de la page parente. L'option s'ouvrira en cliquant sur la sphère représentée dans l'espace tridimensionnel. */
				object.position.x = -24.71516683000315;
				object.position.y = -6.555406638283143;
				object.position.z = 0.6;
				/*Positions dans l'espace - définies principalement par des tests exhaustifs et une comparaison avec un point de référence.*/
				scene.add( object );
				/* ajouter le point d'acupression */

				/*Ci-dessous figurent les autres sphères déclarées de la même manière, seules leur position et leurs noms changent.*/

				var geometry = new THREE.SphereGeometry( 0.3, 32, 32 );

				/* DÉBUT MERIDIEN EXTRAORDINAIRE VAISSEAUX CONCEPTION */

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'vc1';
				object.position.x = 0.05;
				object.position.y = -31.8;
				object.position.z = 4.2;
				scene.add(object);

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'vc2';
				object.position.x = 0.05;
				object.position.y = -6;
				object.position.z = 6.4;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'vc3';
				object.position.x = 0.05;
				object.position.y = -2.9;
				object.position.z = 7.1;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'vc4';
				object.position.x = 0.05;
				object.position.y = 0.20000000000000018;
				object.position.z = 7.17;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'vc5';
				object.position.x = 0.05;
				object.position.y = 3.3000000000000007;
				object.position.z = 7.25;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'vc6';
				object.position.x = 0.05;
				object.position.y = 6.4;
				object.position.z = 7.3;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'vc7';
				object.position.x = 0.05;
				object.position.y = 9.5;
				object.position.z = 7.2;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'vc8';
				object.position.x = 0.05;
				object.position.y = 12.7;
				object.position.z = 6.1;
				scene.add( object );
				
				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'vc9';
				object.position.x = 0.05;
				object.position.y = 15.9;
				object.position.z = 6.1;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'vc10';
				object.position.x = 0.05;
				object.position.y = 18.4;
				object.position.z = 6.38;
				scene.add( object );
				
				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'vc11';
				object.position.x = 0.05;
				object.position.y = 20.9;
				object.position.z = 6.38;
				scene.add( object );
				
				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'vc12';
				object.position.x = 0.05;
				object.position.y = 23.4;
				object.position.z = 6.58;
				scene.add( object );
				
				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'vc13';
				object.position.x = 0.05;
				object.position.y = 25.9;
				object.position.z = 6.6;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'vc14';
				object.position.x = 0.05;
				object.position.y = 28.4;
				object.position.z = 5.95;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'vc15';
				object.position.x = 0.05;
				object.position.y = 30.9;
				object.position.z = 5.06;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'vc16';
				object.position.x = 0.05;
				object.position.y = 33.4;
				object.position.z = 4.9;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'vc17';
				object.position.x = 0.05;
				object.position.y = 36;
				object.position.z = 4.7;				
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'vc18';
				object.position.x = 0.05;
				object.position.y = 38.6;
				object.position.z = 3.6;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'vc19';
				object.position.x = 0.05;
				object.position.y = 41.2;
				object.position.z = 2.4;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'vc20';
				object.position.x = 0.05;
				object.position.y = 43.8;
				object.position.z = 1.2;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'vc21';
				object.position.x = 0.05;
				object.position.y = 46.4;
				object.position.z = -0.9;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'vc22';
				object.position.x = 0.05;
				object.position.y = 49;
				object.position.z = -2.1;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'vc23';
				object.position.x = 0.02;
				object.position.y = 56;
				object.position.z = -0.2;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'vc24';
				object.position.x = 0.02;
				object.position.y = 60;
				object.position.z = 5;				
				scene.add( object );
				/* FIN MERIDIEN EXTRAORDINAIRE VAISSEAUX CONCEPTION */

				/* DÉBUT MERIDIEN POUMON */

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'p1';				
				object.position.x = -13.267798006864483;
				object.position.y = 46.00000000000004;
				object.position.z = -1.0999999999999999;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'p2';				
				object.position.x = -11.26779800686449;
				object.position.y = 48.60000000000008;
				object.position.z = -3.4000000000000026;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'p3';				
				object.position.x = -22.967798006864573;
				object.position.y = 32.39999999999985;
				object.position.z = -4.7;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'p4';				
				object.position.x = -23.56779800686458;
				object.position.y = 28.699999999999797;
				object.position.z = -4.999999999999999;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'p5';				
				object.position.x = -24.16779800686459;
				object.position.y = 15.69999999999962;
				object.position.z = -4.6000000000000005;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'p6';				
				object.position.x = -25.767798006864613;
				object.position.y = 7.499999999999648;
				object.position.z = -2.7000000000000015;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'p7';				
				object.position.x = -26.96779800686463;
				object.position.y = -1.5000000000003426;
				object.position.z = -1.5000000000000004;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'p8';				
				object.position.x = -26.26779800686462;
				object.position.y = -3.500000000000344;
				object.position.z = -0.5000000000000001;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'p9';				
				object.position.x = -27.367798006864636;
				object.position.y = -5.500000000000339;
				object.position.z = -0.30000000000000016;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'p10';				
				object.position.x = -27.66779800686464;
				object.position.y = -7.7000000000003315;
				object.position.z = 2.1000000000000005;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'p11';				
				object.position.x = -30.56779800686468;
				object.position.y = -13.200000000000312;
				object.position.z = 5.999999999999995;
				scene.add( object );

				/* FIN MERIDIEN POUMON */

				/* DÉBUT MÉRIDIEN GROS INTESTIN */

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'ig1';				
				object.position.x = 29.232201993135632;
				object.position.y = -20.00000000000036;
				object.position.z = 6.199999999999994;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'ig2';				
				object.position.x = 29.332201993135634;
				object.position.y = -14.700000000000307;
				object.position.z = 2.8000000000000007;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'ig3';				
				object.position.x = 29.532201993135637;
				object.position.y = -12.200000000000315;
				object.position.z = 1.7999999999999998;
				scene.add( object );
				
				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'ig4';				
				object.position.x = 29.532201993135637;
				object.position.y = -10.500000000000322;
				object.position.z = 0.39999999999999936;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'ig5';				
				object.position.x = 28.33220199313562;
				object.position.y = -6.800000000000335;
				object.position.z = 0.39999999999999925;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'ig6';				
				object.position.x = 28.032201993135615;
				object.position.y = -0.3000000000003421;
				object.position.z = -3.8000000000000025;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'ig7';				
				object.position.x = 27.832201993135612;
				object.position.y = 4.399999999999659;
				object.position.z = -6.399999999999994;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'ig8';				
				object.position.x = 27.73220199313561;
				object.position.y = 9.69999999999964;
				object.position.z = -8.099999999999989;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'ig9';				
				object.position.x = 27.532201993135608;
				object.position.y = 11.999999999999632;
				object.position.z = -8.799999999999986;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'ig10';				
				object.position.x = 27.232201993135604;
				object.position.y = 14.299999999999624;
				object.position.z = -9.299999999999985;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'ig11';				
				object.position.x = 27.0322019931356;
				object.position.y = 17.59999999999964;
				object.position.z = -8.799999999999986;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'ig12';				
				object.position.x = 26.632201993135595;
				object.position.y = 20.49999999999968;
				object.position.z = -8.599999999999987;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'ig13';				
				object.position.x = 26.432201993135592;
				object.position.y = 23.499999999999723;
				object.position.z = -9.299999999999985;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'ig14';				
				object.position.x = 24.73220199313557;
				object.position.y = 33.29999999999986;
				object.position.z = -7.599999999999991;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'ig15';				
				object.position.x = 20.432201993135507;
				object.position.y = 47.20000000000006;
				object.position.z = -5;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'ig16';				
				object.position.x = 18.132201993135475;
				object.position.y = 48.80000000000008;
				object.position.z = -6.499999999999995;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'ig17';				
				object.position.x = 5.532201993135482;
				object.position.y = 54.10000000000016;
				object.position.z = -4.0000000000000036;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'ig18';				
				object.position.x = 5.132201993135483;
				object.position.y = 56.100000000000186;
				object.position.z = -3.600000000000003;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'ig19';				
				object.position.x = 0.9322019931354847;
				object.position.y = 62.400000000000276;
				object.position.z = 4.899999999999998;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );
				object.name = 'ig20';				
				object.position.x = 1.9322019931354855;
				object.position.y = 62.90000000000028;
				object.position.z = 4.3;
				scene.add( object );

				/* FIN MÉRIDIEN GROS INTESTIN  */

				/* DÉBUT MÉRIDIEN ESTOMAC  */

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e1';
				object.position.x = -2.9677980068645167;
				object.position.y = 66.70000000000014;
				object.position.z = 3;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e2';
				object.position.x = -2.9677980068645167;
				object.position.y = 66.00000000000018;
				object.position.z = 3.2;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e3';
				object.position.x = -2.8677980068645166;
				object.position.y = 63.700000000000294;
				object.position.z = 3.8000000000000007;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e4';
				object.position.x = -2.7677980068645165;
				object.position.y = 61.10000000000026;
				object.position.z = 4.1000000000000005;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e5';
				object.position.x = -3.367798006864517;
				object.position.y = 58.200000000000216;
				object.position.z = 2.4999999999999996;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e6';
				object.position.x = -5.967798006864511;
				object.position.y = 61.30000000000026;
				object.position.z = -2.6000000000000028;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e7';
				object.position.x = -6.467798006864509;
				object.position.y = 64.20000000000029;
				object.position.z = -2.700000000000003;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e8';
				object.position.x = -6.26779800686451;
				object.position.y = 71.89999999999985;
				object.position.z = -2.700000000000003;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e9';
				object.position.x = -2.9677980068645167;
				object.position.y = 54.20000000000016;
				object.position.z = -2.3000000000000025;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e10';
				object.position.x = -2.267798006864516;
				object.position.y = 51.40000000000012;
				object.position.z = -2.2000000000000024;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e11';
				object.position.x = -2.9677980068645167;
				object.position.y = 47.600000000000065;
				object.position.z = -1.2000000000000015;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e12';
				object.position.x = -6.667798006864508;
				object.position.y = 48.60000000000008;
				object.position.z = -2.2000000000000024;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e13';
				object.position.x = -7.067798006864507;
				object.position.y = 47.600000000000065;
				object.position.z = -1.0000000000000013;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e14';
				object.position.x = -7.667798006864505;
				object.position.y = 44.800000000000026;
				object.position.z = 0.8999999999999986;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e15';
				object.position.x = -8.767798006864501;
				object.position.y = 42.29999999999999;
				object.position.z = 2.3999999999999995;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e16';
				object.position.x = -9.867798006864497;
				object.position.y = 38.89999999999994;
				object.position.z = 4.2;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e17';
				object.position.x = -12.06779800686449;
				object.position.y = 33.19999999999986;
				object.position.z = 4.999999999999997;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e18';
				object.position.x = -12.06779800686449;
				object.position.y = 30.199999999999818;
				object.position.z = 2.1999999999999993;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e19';
				object.position.x = -3.167798006864517;
				object.position.y = 25.699999999999754;
				object.position.z = 6.599999999999992;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e20';
				object.position.x = -3.167798006864517;
				object.position.y = 22.64727272727248;
				object.position.z = 6.699999999999991;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e21';
				object.position.x = -3.167798006864517;
				object.position.y = 19.59454545454521;
				object.position.z = 6.699999999999991;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e22';
				object.position.x = -3.167798006864517;
				object.position.y = 16.541818181817938;
				object.position.z = 6.499999999999992;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e23';
				object.position.x = -3.167798006864517;
				object.position.y = 13.489090909090663;
				object.position.z = 6.699999999999991;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e24';
				object.position.x = -3.167798006864517;
				object.position.y = 10.43636363636339;
				object.position.z = 7.09999999999999;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e25';
				object.position.x = -3.167798006864517;
				object.position.y = 7.383636363636118;
				object.position.z = 6.99999999999999;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e26';
				object.position.x = -3.167798006864517;
				object.position.y = 4.330909090908847;
				object.position.z = 6.899999999999991;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e27';
				object.position.x = -3.167798006864517;
				object.position.y = 1.2781818181815723;
				object.position.z = 6.599999999999992;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e28';
				object.position.x = -3.167798006864517;
				object.position.y = -1.7745454545457022;
				object.position.z = 6.299999999999993;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e29';
				object.position.x = -3.167798006864517;
				object.position.y = -4.827272727272973;
				object.position.z = 5.699999999999995;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e30';
				object.position.x = -3.167798006864517;
				object.position.y = -7.880000000000244;
				object.position.z = 4.599999999999999;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e31';
				object.position.x = -12.467798006864488;
				object.position.y = -11.280000000000232;
				object.position.z = 4.100000000000001;
				scene.add( object );


				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e32';
				object.position.x = -12.467798006864488;
				object.position.y = -28.48000000000039;
				object.position.z = 4.300000000000001;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e33';
				object.position.x = -12.467798006864488;
				object.position.y = -36.2800000000005;
				object.position.z = 2.900000000000001;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e34';
				object.position.x = -12.467798006864488;
				object.position.y = -38.98000000000054;
				object.position.z = 2.3000000000000003;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e35';
				object.position.x = -12.467798006864488;
				object.position.y = -47.18000000000065;
				object.position.z = 1.4999999999999996;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e36';
				object.position.x = -12.467798006864488;
				object.position.y = -53.18000000000074;
				object.position.z = -0.10000000000000153;
				scene.add( object );


				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e37';
				object.position.x = -12.467798006864488;
				object.position.y = -63.68000000000089;
				object.position.z = -0.7000000000000015;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e38';
				object.position.x = -11.76779800686449;
				object.position.y = -69.78000000000057;
				object.position.z = -1.6000000000000019;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e39';
				object.position.x = -11.367798006864492;
				object.position.y = -73.28000000000037;
				object.position.z = -1.9000000000000021;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e40';
				object.position.x = -13.467798006864484;
				object.position.y = -69.48000000000059;
				object.position.z = -4.3000000000000025;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e41';
				object.position.x = -8.667798006864501;
				object.position.y = -85.1799999999997;
				object.position.z = -0.8000000000000016;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e42';
				object.position.x = -9.967798006864497;
				object.position.y = -88.27999999999952;
				object.position.z = 0.9999999999999983;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e43';
				object.position.x = -8.8677980068645;
				object.position.y = -90.97999999999936;
				object.position.z = 6.099999999999993;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e44';
				object.position.x = -9.467798006864498;
				object.position.y = -91.87999999999931;
				object.position.z = 7.799999999999988;
				scene.add( object );

				var object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: 0x006aff } ) );
				object.name = 'e45';
				object.position.x = -9.967798006864497;
				object.position.y = -93.17999999999924;
				object.position.z = 11.299999999999976;
				scene.add( object );

				/* FIN MÉRIDIEN ESTOMAC  */
				var manager = new THREE.LoadingManager();
				manager.onProgress = function ( item, loaded, total ) {

					console.log( item, loaded, total );
					/* Escreve no console do browser o andamento do carregamento */

				};
				/* Gerenciador de carregamento vide https://threejs.org/docs/#Reference/Loaders/LoadingManager */

				var texture = new THREE.Texture();

				var onProgress = function ( xhr ) {
					if ( xhr.lengthComputable ) {
						var percentComplete = xhr.loaded / xhr.total * 100;
						console.log( Math.round(percentComplete, 2) + '% downloaded' );
					}
				};
				/* não sei do que se trata a variável xhr, mas essa função serve para retornar a quantidade em porcentagem de quanto já carregou e quanto falta carregar do OBJETO (corpo humano). Desconsiderar essa função */

				var onError = function ( xhr ) {
				};
				/* desconsiderar*/

				var loader = new THREE.ImageLoader( manager );
				loader.load( 'three/textura/UV_Grid_Sm.jpg', function ( image ) {

					texture.image = image;
					texture.needsUpdate = true;

				} );
				/* Carrega a textura vide https://threejs.org/docs/#Reference/Loaders/ImageLoader */

				var loader = new THREE.OBJLoader( manager );
				/* instancia o carregador de objeto vide https://threejs.org/docs/#Reference/Loaders/OBJLoader */
				var material = new THREE.MeshBasicMaterial({color: 'yellow', side: THREE.DoubleSide});
				/* desconsiderar, aplica a cor ao objeto - só aparece sem a textura */
				loader.load( 'three/modelo/corpo.obj', function ( object ) {

					object.traverse( function ( child ) {

						if ( child instanceof THREE.Mesh ) {

							child.material.map = texture;

						}

					} );

					object.position.y = - 95;
					scene.add( object );

				}, onProgress, onError );
				/* carrega o objeto corpo.obj e aplica a textura */
				raycaster = new THREE.Raycaster();
				/* declara a variavel raycaster, que é instanciada pelo construtor Raycaster(), usado para clicar em objetos tridimensionais - funciona como um raio projetado ao longo do eixo Z, (o mouse trabalha em 2 dimensoes), o raycaster faz um procedimento que quando o mouse é clicado, vai verificando-se ao longo da reta Z com os eixos X e Y fixados pela POSIÇÃO do mouse. Quando um objeto é encontrado, ele é adicionado à um vetor de INTERSECÇÕES. Podendo assim acessá-lo e verificar quais objetos estão no caminho. */
				renderer = new THREE.WebGLRenderer();
				/* O renderizador WebGL exibe a cena trabalhada usando o WebGL, se o dispositivo suportar.*/

				renderer.setPixelRatio( window.devicePixelRatio );
				/* Define a proporção de pixel do dispositivo em questão, passando como parâmetro esta informação, obtida pelo comando window.devicePixelRatio. Geralmente usado para dispositivos HiDPI, a fim de evitar sobreposição de imagens no CANVAS*/
				renderer.setSize( window.innerWidth, window.innerHeight );
				/* Define o tamanho da tela de renderização - neste caso o tamanho de ALTURA e LARGURA da janela (total)*/
				container.appendChild( renderer.domElement );
				/* Insere o elemento CANVAS no container, onde será renderizado o WebGL
				   A variável container foi declarada na linha 91 */

				window.addEventListener( 'keydown', keyDownTextField, false);

				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				/*desconsiderar*/

				document.addEventListener( 'mousedown', onDocumentMouseDown, false );
				/*Declara uma escuta para eventos de click do mouse. Cada vez que o mouse é clicado, a função onDocumentMouseDown é chamada.*/
				window.addEventListener( 'resize', onWindowResize, false );
				/*desconsiderar*/
			}

			function keyDownTextField(e) {
			    if (e.keyCode == '38') {
			    	uPressed = true;
			    }
			    else if (e.keyCode == '40') {
			        dPressed = true;
			    }
			    else if (e.keyCode == '37') {
			        lPressed = true;
			    }
			    else if (e.keyCode == '39') {
			    	rPressed = true;
			    }
			    else if (e.keyCode == '107') {
			    	pPressed = true;
			    }
			    else if (e.keyCode == '109') {
			    	mPressed = true;
			    }
			    else if (e.keyCode == '188') {
			    	controls.enabled = false;
			    }
			    else if (e.keyCode == '190') {
			    	controls.enabled = true;
			    }
			}

			function onWindowResize() {

				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}
			/*desconsiderar*/

			function onDocumentMouseMove( event ) {

				event.preventDefault();

				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

				mouseX = ( event.clientX - windowHalfX ) / 2;
				mouseY = ( event.clientY - windowHalfY ) / 2;

			}
			/*desconsiderar*/

			function onDocumentMouseDown( event ) {

				event.preventDefault();
				/* Faz cancelar qualquer ação padrão a ser executado durante o click do mouse. Prevenir uma ação inesperada, para tratar corretamente o clique do mouse */

				raycaster.setFromCamera( mouse, camera );
				/* Atualiza as informações FromCamera do raycaster onde
				mouse: coordenadas 2D do mouse.
				camera: camera pela qual o raio tem origem*/

				var intersects = raycaster.intersectObjects( scene.children );
				/*
					Executa o método que registra em um vetor os objetos encontrados ao longo do raio. Onde:
					scene.children: todos os objetos que serão verificados pelo raio. Neste caso, usa-se scene.children para incluir TODOS os objetos (filhos da cena).
				*/
				if ( intersects.length > 0 ) {
					/* intersects.lenght retorna a quantidade de elementos. Se a quantidade de elementos for > 0 faça: */

					if ( INTERSECTED != intersects[ 0 ].object ) {
						/* se o objeto não for na primeira posição (pois este é o corpo humano e ele sempre vai estar lá)
						FAÇA
						*/						
						if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );
						/* Recupera a cor padrão do objeto (esfera no caso) */
						INTERSECTED = intersects[ 0 ].object;
						/* armazena na variavel INTERSECTED o objeto encontrado*/
						INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
						INTERSECTED.material.emissive.setHex( 0xff0000 );
						/* Altera a cor do objeto para vermelho(esfera no caso) */
						animacao = parent.document.getElementById(INTERSECTED.nome);
						/* recupera e armazena em animacao o elemento com o ID do nome da esfera*/
						console.log(INTERSECTED.name);
						console.log('\n\t\t\t\tobject.position.x = '+INTERSECTED.position.x+';\n\t\t\t\t'+'object.position.y = '+INTERSECTED.position.y+';\n'+'\t\t\t\tobject.position.z = '+INTERSECTED.position.z+';\n');
						//console.log('object.position.y = '+INTERSECTED.position.y+';\n');
						//console.log('object.position.z = '+INTERSECTED.position.z+';\n');
						//console.log(INTERSECTED.position.x, INTERSECTED.position.y, INTERSECTED.position.z);
						animacao.click();
						/*clica-se involuntariamente no objeto com o ID igual ao do NOME da esfera, fazendo abrir na pagina pai o botão relacionado com a esfera clicada */
					}
				} else {
					/* caso contrário */
					if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );
					/*  atualiza a esfera para a cor padrão, visto que o clique foi em outra coisa que não foi a última esfera clicada */

					INTERSECTED = null;

				}
			}

			function acuPonto(x, y, z) {
			/* declaração da função acuPonto, que recebe apenas as 3 coordenadas onde a câmera irá se aproximar */
				acuX = x;
				acuY = y;
				acuZ = z;
				/* armazena as coordenadas recebidas por parâmetro nas variáveis globais para uso posterior */
				
				p.set( acuX, acuY, acuZ );
				/* p é um vetor tridimensional declarado na linha 41
				aqui estamos alterando os valores de sua coordenada, para os valores recebidos pela função */

				focoCamera = true;
				/* aqui definimos a variavel global focoCamera para TRUE, ela fora declarada como FALSE na linha 39 */
			}

			function animate() {
				/* pequena função com duas instruções, mas responsável por animar a câmera chamando-a recursivamente */
				requestAnimationFrame( animate );
				/* função nativa do javascript, introduzida recentemente. Sanou varios problemas que persistiam quando utilizávamos setInterval(), deixando todo o gerenciamento de tempo e hardware para o navegador. Seria interessante falar sobre isso,
				mas basicamente com este comando podemos realizar uma animação por X frames por segundo, passando uma função que será re-executada infinitas vezes - neste caso a função animate está sendo chamada recursivamente. */
				render();
				/* chama a função render agora com os valores atualizados pela mesma função render, criando uma espécie de animação frame a frame*/
			}

			function render() {
				/* função responsável por renderizar a cena */
				renderer.render( scene, camera );
				/* renderiza uma cena utilizando uma câmera, neste caso, scene e camera */
				if (uPressed) {
					var obj = scene.getObjectByName(idponto);
					obj.position.y = obj.position.y+0.1;
					uPressed = false;
				}
				if (dPressed) {
					var obj = scene.getObjectByName(idponto);
					obj.position.y = obj.position.y-0.1;
					dPressed = false;
				}
				if (lPressed) {
					var obj = scene.getObjectByName(idponto);
					obj.position.x = obj.position.x-0.1;
					lPressed = false;
				}
				if (rPressed) {
					var obj = scene.getObjectByName(idponto);
					obj.position.x = obj.position.x+0.1;
					rPressed = false;
				}
				if (pPressed) {
					var obj = scene.getObjectByName(idponto);
					obj.position.z = obj.position.z-0.1;
					pPressed = false;
				}
				if (mPressed) {
					var obj = scene.getObjectByName(idponto);
					obj.position.z = obj.position.z+0.1;
					mPressed = false;
				}
				if (focoCamera) { // SE (focoCamera == TRUE) faça
					/* variável global que é definida como TRUE quando é clicado em uma esfera ou clicada em um botão referente à um acuponto na barra lateral
					Basicamente, é a estrutura de condição que faz acontecer a animação da câmera
					*/
					if (camera.position.x != acuX) { /* Se a posição da câmera no eixo x for diferente do ponto que queremos chegar FAÇA */
						if (camera.position.x > acuX) { // se a posição da camera em X for maior que o valor de X que queremos chegar
							camera.position.x--; // Incrementa 1 unidade o valor da posição da camera.x
						} else { // caso contrário
							camera.position.x++; // Decrementa 1 unidade o valor da posição da camera.x
						}
						if (Math.round(camera.position.x) == Math.round(acuX)) { // Se o valor INTEIRO da posição da camera.x for IGUAL ao valor INTEIRO da posição do ponto pretendido
							camera.position.x = acuX;
							//a posição da camera em x recebe o valor exato do acuponto em x.
						}
					}


					if (camera.position.y != acuY) {
						/* Se a posição da câmera no eixo y for diferente do ponto que queremos chegar FAÇA */
						if (camera.position.y > acuY) { // se a posição da camera em Y for maior que o valor de Y do acuponto que queremos chegar
							camera.position.y--; // Decrementa 1 unidade o valor da posição da camera.y
						} else {
							camera.position.y++; // Incrementa 1 unidade o valor da posição da camera.y
						}
						
						if (Math.round(camera.position.y) == Math.round(acuY)) { // Se o valor INTEIRO da posição da camera.x for IGUAL ao valor INTEIRO da posição do ponto pretendido
							camera.position.y = acuY;
							//a posição da camera em y recebe o valor exato do acuponto em y.
						}
					}

					if (camera.position.z != acuZ+45) {
						/* Se a posição da câmera no eixo z for diferente do acuponto na posição Z+45 (+45 pois a camera do eixo Z deve ficar um pouco afastada e não grudada no ponto) que queremos chegar FAÇA */
						if (camera.position.z > acuZ+45) { // se a posição da camera em Z for maior que o valor de Z+45 do acuponto que queremos chegar
							camera.position.z--; // Decrementa 1 unidade o valor da posição da camera.z
						} else {
							camera.position.z++; // Incrementa 1 unidade o valor da posição da camera.z
						}
						if (Math.round(camera.position.z) == Math.round(acuZ+45)) { // Se o valor INTEIRO da posição da camera.z for IGUAL ao valor INTEIRO da posição z+45 do ponto pretendido
							camera.position.z = acuZ+45;
							//a posição da camera em z recebe o valor exato do acuponto em z.
						}
					}
					if ((camera.position.z == acuZ+45)&&(camera.position.y == acuY)&&(camera.position.x == acuX)) {
						focoCamera = false;
						controls.target = p;
						return;
					} /* se todas as condições estiverem satisfeitas, que é a camera exatamente no acuponto selecionado (exceto em z, que é z+45 para a camera nao ficar grudada no ponto), então alteramos a variável global focoCamera para FALSE, portanto quando entrar na função render novamente será verificada esta variável, e como ela estará FALSE não entrará nessas condições para animação. A única forma de focoCamera tornar-se TRUE será quando for clicado em um acuponto ou em um botão na barra lateral */
					camera.lookAt( p );
					/* lookAt( p ) => Em p está armazenada a coordenada do ponto em questão (onde a camera deverá se aproximar), portanto invocamos o metodo da camera -> lookAt(p) que recebe como parâmetro um ponto do tipo vetor tridimensional (neste caso, p) para que a câmera fique "olhando" para o ponto enquanto ela se aproxima (torna a animação mais agradavel, fica focada no ponto)*/
				}
			}

		</script>
	</body>
</html>
